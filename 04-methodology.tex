We describe a methodology for detecting and verifying newly added unchecked exceptions in a library when it is updated from an older version to a newer one. Our focus is on identifying the impact of such changes on client code. Specifically, we analyze client programs to detect usage of library methods that now throw previously non-existent unchecked exceptions. Java distinguishes between checked exceptions, which appear as part of method signatures, and unchecked exceptions, which do not. Unchecked exceptions may therefore introduce a class of breaking changes that signature-based syntactic approaches for Java do not detect.

We begin by collecting both the client programs and the necessary information to perform our analysis. Specifically, we extract all external library methods invoked by the client. For each of these methods, we analyze their implementation in both the version of the library currently used by the client and the latest version. This allows us to compare their behaviour across versions. If we find that a method now throws a newly added unchecked exception in the latest version, and that the exception can be triggered from the client code, we report a potential behavioural breaking change. To verify whether this change is in fact breaking, we currently manually write test cases to verify that the client may be affected by the newly introduced exception.

\subsection{Analysis Setup}

The analysis setup is divided into two main phases: client selection and knowledge extraction for analysis\todo{needs a pipeline diagram}.

\subsubsection{Client Selection}

As described in Section~\ref{sec:data-collection}, we begin by selecting Java-based clients from the DUETS dataset~\cite{durieux21:_duets}. We retain only those clients that are Maven-compatible and successfully compile to a JAR file, ensuring compatibility with our analysis tooling. We initially compile each client using the library versions specified in its original configuration, since some clients fail to compile when their dependencies are upgraded. These failures are typically caused by method signature changes in the newer library versions, which the compiler detects and treats as errors. After generating the client JAR file using its originally defined dependencies, we then upgrade the libraries to their latest available versions in order to obtain the corresponding updated JAR files for those libraries for further analysis.

\todo{TBR}

\subsubsection{Knowledge Extraction for Analysis}

After selecting valid clients, we used SootUp~\cite{Karakaya24:_sootup} to extract all external method calls made by each client---that is, calls from the client to some library (including the standard library). UnCheckGuard does this by traversing all methods in the client and identifying occurrences of \texttt{JInvokeStmt}\todo{check that you don't actually need to verify instanceof InvokableStmt}, which represent method invocation statements. At the same time, we collected both the old and new versions of the libraries used by the client\todo{from where---though maybe that part should also be in section 3}, obtaining the corresponding JAR files for each version. We also analyzed these libraries were using SootUp to extract all available method signatures.

By correlating the external method calls from the client with the methods defined in each library, we constructed an accurate mapping between client calls and the corresponding library methods. This mapping enabled us to track how the behaviour of the library methods evolved across versions.

This stage of our methodology yields JAR files for both the old and new versions of each library, along with a filtered list of external methods that are candidates for further analysis. These methods form the basis for detecting newly introduced unchecked exceptions that may lead to behavioural breaking changes in the client.

\subsection{Finding Newly Added Unchecked Exceptions}

Our primary goal is to detect whether upgrading a library introduces new unchecked exceptions that could affect client behaviour. To achieve this, we divide the process into two stages: first, identifying newly added unchecked exceptions using a call graph; and second, verifying their reachability from client input using a taint analysis.

\subsubsection{Exception Discovery with RTA}

To detect newly added unchecked exceptions in the upgraded library, we first construct a call graph using Rapid Type Analysis~\cite{bacon96:_fast_static_analy_c_virtual_funct_calls} (RTA) via SootUp~\cite{Karakaya24:_sootup}. We use RTA instead of Class Hierarchy Analysis (CHA) because RTA provides a more precise approximation of runtime behaviour in the context of a particulaar client/library pair. CHA, working on the class hierarchy, includes all methods defined in subclasses and interface implementations regardless of whether they are actually invoked. RTA instead considers only those types that are instantiated in the program (client plus libraries), resulting in a more accurate call graph.

By definition, CHA reports the most conservative soundy~\cite{livshits15:_in} answer possible, absent reflection. Thus, it tends to over-approximate and report unreachable method calls. For example, in one case, CHA identified a path from the method \texttt{<com.alibaba.fastjson.JSONObject: java.lang.String getString (java.lang.String)>}, reporting an exception thrown in the \texttt{JSONObject} constructor as reachable. However, manual inspection revealed that this path was spuriousâ€”the method \texttt{getString} never actually reaches the constructor in question, for the program that we are considering\todo{why? what isn't instantiated?}. Using RTA eliminated such false positives by restricting analysis to only types that are concretely instantiated in the program.
% we should probably make this whole discussion more concise when we have space limitations

After building the RTA-based call graph, we traverse the reachable paths for each client-used method and collect all exceptions that are subclasses of \texttt{java.lang.RuntimeException} or \texttt{java.lang.Error}. Per the definition of the Java programming language, such exceptions represent the complete set of unchecked exceptions that the client might be newly exposed to due to the library upgrade.

\subsubsection{Exception Verification with Taint Analysis}

Once the list of unchecked exceptions has been collected, we filter out some unchecked exceptions that can not be triggered by the client that we are analyzing. We use \textbf{FlowDroid}~\cite{Arzt14:_flowdroid}, a static taint analysis framework, for this purpose.

To enable taint analysis, we automatically generate a \textit{driver stub} for each client-used method\todo{what is a client-used method?}. The purpose of this stub is to declare each method parameter as a taint source. For each parameter, we define a wrapper function and mark its return value as a FlowDroid source. Driver stub generation, implemented using SootUp, handles a wide variety of cases, including:
\begin{itemize}
  \item Constructor methods (\texttt{<init>} using \texttt{new ClassName(...)})
  \item Static and instance methods
  \item Void and non-void return types
  \item Primitive parameters (e.g., \texttt{int} $\rightarrow$ \texttt{0})
  \item Object parameters (defaulted to \texttt{null})
  \item Nested classes (converting \texttt{\$} to \texttt{.})
  \item Multiple parameters (sources named \texttt{SourceN()}, where $N$ is the parameter index)
  \item Overloaded methods (only one version retained)
\end{itemize}

Each exception collected during the RTA phase is treated as a \textit{taint sink}. For this analysis, we intentionally use Class Hierarchy Analysis (CHA) to construct the call graph for FlowDroid. Although CHA is less precise than RTA, its conservative nature is beneficial in this context. It ensures broader coverage, helping us avoid false negatives where actual flows might be missed due to the strictness of RTA.

Consider the following example from the \texttt{beam-sdks-java-core} library. The method \texttt{GroupByKey.applicableTo(PCollection)} (shown here edited for length) throws an \texttt{IllegalStateException} under a specific condition:
\begin{lstlisting}[language=Java,breaklines=true,breakatwhitespace=false,basicstyle=\scriptsize\ttfamily]
public static void applicableTo(PCollection<?> input) {
    WindowingStrategy<?, ?> ws = input.getWindowingStrategy();
    if (ws.getWindowFn() instanceof GlobalWindows
        && ws.getTrigger() instanceof DefaultTrigger
        && input.isBounded() != IsBounded.BOUNDED) {
      throw new IllegalStateException(
          "GroupByKey cannot be applied to non-bounded PCollection in the GlobalWindow without a"
              + " trigger. Use a Window.into or Window.triggering transform prior to GroupByKey.");
    }
}
\end{lstlisting}

Here, the source is the method parameter \texttt{input}, and the sink is the \texttt{IllegalStateException}. Since the exception is conditionally thrown, RTA does not resolve the path from the input parameter to the exception\todo{must check that we're saying only things that are true; I think it is, but we should say exactly why RTA doesn't include this}. However, due to its conservative over-approximation, CHA includes the conditional path, allowing the taint analysis to correctly identify the exception as being influenced by client input.

This trade-off justifies the use of CHA in the verification phase: although it may over-approximate in some cases, it ensures that no critical exception flows are missed.


\subsection{Verification of Unchecked Exceptions}
