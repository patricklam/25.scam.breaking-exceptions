We describe a methodology for detecting and verifying newly added unchecked exceptions in a library when it is updated from an older version to a newer one. Our focus is on identifying the impact of such changes on client code. Specifically, we analyze client programs to detect usage of library methods that now throw previously non-existent unchecked exceptions. Java distinguishes between checked exceptions, which appear as part of method signatures, and unchecked exceptions, which do not. Unchecked exceptions may therefore introduce a class of breaking changes that signature-based syntactic approaches for Java do not detect.

We begin by collecting both the client programs and the necessary information to perform our analysis. Specifically, we extract all external library methods invoked by the client. For each of these methods, we analyze their implementation in both the version of the library currently used by the client and the latest version. This allows us to compare their behaviour across versions. If we find that a method now throws a newly added unchecked exception in the latest version, and that the exception can be triggered from the client code, we report a potential behavioural breaking change. To verify whether this change is in fact breaking, we currently manually write test cases to verify that the client may be affected by the newly introduced exception.

\subsection{Analysis Setup}

The analysis setup is divided into two main phases: client selection and knowledge extraction for analysis\todo{needs a pipeline diagram}.

\subsubsection{Client Selection}

As described in Section~\ref{sec:data-collection}, we begin by selecting Java-based clients from the DUETS dataset~\cite{durieux21:_duets}. We retain only those clients that are Maven-compatible and successfully compile to a JAR file, ensuring compatibility with our analysis tooling. We initially compile each client using the library versions specified in its original configuration, since some clients fail to compile when their dependencies are upgraded. These failures are typically caused by method signature changes in the newer library versions, which the compiler detects and treats as errors. After generating the client JAR file using its originally defined dependencies, we then upgrade the libraries to their latest available versions in order to obtain the corresponding updated JAR files for those libraries for further analysis.

\todo{TBR}

\subsubsection{Knowledge Extraction for Analysis}

After selecting the valid clients and compiling them into JAR files, we proceed to extract relevant method-level knowledge from both the client and the current version of the libraries it depends on. The process for acquiring the client and library JAR files is described in Section~\ref{sec:data-collection}.

We use SootUp~\cite{Karakaya24:_sootup} to analyze the client JAR and identify all external method invocations. UnCheckGuard performs this analysis by traversing the Jimple body of each client method and checking whether any statement contains an \texttt{InvokeExpr}, which represents a method invocation. For each invocation, we retrieve the declaring class type of the target method. We then check whether this class type is part of the client’s SootUp view. If the class type is not found in the view, we mark the method as external. This process allows us to filter out internal method calls and focus only on invocations to library methods.

In parallel, we analyze the current (i.e., pre-upgrade) version of each library used by the client. Using SootUp, we extract all method signatures defined in the library JAR. We then match each external method call made by the client to the corresponding method in the library by comparing their fully qualified method signatures. This one-to-one mapping enables us to identify exactly which library methods are invoked by which client methods.

At the end of this stage, we produce a structured mapping between client methods and the external library methods they invoke. This mapping serves as a foundation for later stages in our analysis, where we detect behavioural changes in upgraded library versions and trace their potential impact on client call sites\todo{TBR}.

\subsection{Finding Newly Added Unchecked Exceptions}

Our primary goal is to detect whether upgrading a library introduces new unchecked exceptions that could affect client behaviour. To achieve this, we divide the process into two stages: first, identifying newly added unchecked exceptions using a call graph; and second, verifying their reachability from client input using a taint analysis.

\subsubsection{Exception Discovery with RTA}

To detect newly added unchecked exceptions in the upgraded library, we first construct a call graph using Rapid Type Analysis~\cite{bacon96:_fast_static_analy_c_virtual_funct_calls} (RTA) via SootUp~\cite{Karakaya24:_sootup}. We use RTA instead of Class Hierarchy Analysis (CHA) because RTA provides a more precise approximation of runtime behaviour in the context of a particulaar client/library pair. CHA, working on the class hierarchy, includes all methods defined in subclasses and interface implementations regardless of whether they are actually invoked. RTA instead considers only those types that are instantiated in the program (client plus libraries), resulting in a more accurate call graph.

By definition, CHA reports the most conservative soundy~\cite{livshits15:_in} answer possible, absent reflection. Thus, it tends to over-approximate and report unreachable method calls. For example, in one case, CHA identified a path from the method \texttt{<com.alibaba.fastjson.JSONObject: java.lang.String getString (java.lang.String)>}, reporting an exception thrown in the \texttt{JSONObject} constructor as reachable. However, manual inspection revealed that this path was spurious—the method \texttt{getString} never reaches the constructor in question because, in the specific program under analysis, no code instantiates a \texttt{JSONObject}. RTA excludes such paths because it considers only types that are actually instantiated, whereas CHA includes all potential subtype relationships, regardless of runtime feasibility\todo{TBR}.
% we should probably make this whole discussion more concise when we have space limitations

After building the RTA-based call graph, we traverse the entire callgraph and collect all exceptions that are subclasses of \texttt{java.lang.RuntimeException} or \texttt{java.lang.Error}. Per the definition of the Java programming language, such exceptions represent the complete set of unchecked exceptions that the client might be newly exposed to due to the library upgrade.

\subsubsection{Exception Verification with Taint Analysis}

Once we collect the list of unchecked exceptions, we filter out those that cannot be triggered by the client. We use \textbf{FlowDroid}~\cite{Arzt14:_flowdroid}, a static taint analysis framework, for this purpose.

To enable taint analysis, we automatically generate a \textit{driver stub} for each library method used by the client. The stub declares each method parameter as a taint source. For each parameter, we define a wrapper function and mark its return value as a FlowDroid source. Stub generation, implemented using SootUp, handles a variety of cases, including:
\begin{itemize}
  \item Constructor methods (\texttt{<init>} using \texttt{new ClassName(...)})
  \item Static and instance methods
  \item Void and non-void return types
  \item Primitive parameters (e.g., \texttt{int} $\rightarrow$ \texttt{0})
  \item Object parameters (defaulted to \texttt{null})
  \item Nested classes (converting \texttt{\$} to \texttt{.})
  \item Multiple parameters (sources named \texttt{SourceN()}, where $N$ is the parameter index)
  \item Overloaded methods (only one version retained)
\end{itemize}

We treat each exception discovered in the RTA phase as a \textit{taint sink}. For this analysis, we intentionally construct the call graph using Class Hierarchy Analysis (CHA). Although CHA is less precise than RTA, it offers conservative coverage, reducing the risk of missing true positive flows due to aggressive pruning.

Consider the following method from the \texttt{beam-sdks-java-core} library:

\begin{lstlisting}[language=Java,breaklines=true,breakatwhitespace=false,basicstyle=\scriptsize\ttfamily]
public static void applicableTo(PCollection<?> input) {
    WindowingStrategy<?, ?> ws = input.getWindowingStrategy();
    if (ws.getWindowFn() instanceof GlobalWindows
        && ws.getTrigger() instanceof DefaultTrigger
        && input.isBounded() != IsBounded.BOUNDED) {
      throw new IllegalStateException("...");
    }
}
\end{lstlisting}

\begin{figure}[t]
\centering
\scalebox{0.75}{
\begin{tikzpicture}[
  node distance=1.4cm and 1.5cm,
  box/.style={rectangle, draw, rounded corners, minimum height=1.2em, text width=2.8cm, align=center, font=\scriptsize},
  every edge/.style={draw, -{Latex[width=2mm]}},
  rededge/.style={draw=red, thick, dashed, -{Latex[width=2mm]}}
  ]

% Nodes
\node[box] (start) {\textbf{Method Entry}\\ \texttt{applicableTo(...)}};
\node[box, below=of start] (cond) {\textbf{Condition}\\ \texttt{input.isBounded() != BOUNDED}};
\node[box, below left=of cond] (exc) {Throws \\ \texttt{IllegalStateExcep...}};
\node[box, below right=of cond] (noexc) {Execution continues};

% Edges
\path (start) edge (cond);
\path (cond) edge (exc);
\path (cond) edge (noexc);

% Labels
\node[align=left, font=\scriptsize] at ([xshift=1.9cm,yshift=0.1cm]cond.east) {\textbf{CHA:} includes both branches};
\draw[rededge] (start.east) to[out=10,in=90] node[right, align=center, font=\scriptsize] {\textbf{RTA:} skips due to\\ unresolved condition} (noexc.west);

\end{tikzpicture}
}
\vspace{-1ex}
\caption{CHA vs. RTA on a conditionally thrown exception. RTA excludes paths guarded by unresolved predicates, whereas CHA includes them.}
\label{fig:rta-vs-cha}
\vspace{-2ex}
\end{figure}


In this example, the parameter \texttt{input} is the taint source, and the exception is the sink. RTA does not evaluate predicates such as \texttt{input.isBounded()} and therefore cannot determine that the exception is reachable from a client-controlled input. CHA, however, includes this conditional path in the call graph due to its broader approximation. As shown in Figure~\ref{fig:rta-vs-cha}, this distinction allows the taint analysis to capture cases that RTA would miss.

This trade-off justifies the use of CHA in the verification phase: although it may over-approximate in some cases, it ensures that no critical exception flows are missed.

\subsection{Verification of Unchecked Exceptions}
