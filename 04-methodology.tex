We describe a methodology for detecting and verifying newly added unchecked exceptions in a library when it is updated from an older version to a newer one. Our focus is on identifying the impact of such changes on client code. Specifically, we analyze client programs to detect usage of library methods that now throw previously non-existent unchecked exceptions. Java distinguishes between checked exceptions, which appear as part of method signatures, and unchecked exceptions, which do not. Unchecked exceptions may therefore introduce a class of breaking changes that signature-based syntactic approaches for Java do not detect.

We begin by collecting both the client programs and the necessary information to perform our analysis. Specifically, we extract all external library methods invoked by the client. For each of these methods, we analyze their implementation in both the version of the library currently used by the client and the latest version. This allows us to compare their behaviour across versions. If we find that a method now throws a newly added unchecked exception in the latest version, and that the exception can be triggered from the client code, we report a potential behavioural breaking change. To verify whether this change is in fact breaking, we currently manually write test cases to verify that the client may be affected by the newly introduced exception.

\subsection{Analysis Setup}

The analysis setup is divided into two main phases: client selection and knowledge extraction for analysis.

\subsubsection{Client Selection}

We began by collecting clients to evaluate our approach. For this, we used the DUETS dataset~\cite{durieux21:_duets}, which provides a curated set of Java-based client programs available on GitHub, each with at least five stars. The first step involved compiling each client's source code to generate the corresponding JAR files required for further analysis. Clients that failed to compile were discarded, as the lack of a compiled artifact prevents further inspection.

All clients were compiled using Java 11. To ensure compatibility with our analysis tooling, we checked whether each project contained a \texttt{pom.xml} file, indicating that it is a Maven-based project. Since our workflow relies on Maven for dependency resolution and build automation, only clients that could be built using Maven were included in our dataset.

\subsubsection{Knowledge Extraction for Analysis}

Once the valid clients were selected, we used SootUp~\cite{Karakaya24:_sootup} to extract all external method calls made by each client. This was accomplished by traversing all methods in the client and identifying occurrences of \texttt{JInvokeStmt}, which represent method invocation statements. In parallel, we collected both the old and new versions of the libraries used by the client, obtaining the corresponding JAR files for each version. These libraries were also analyzed using SootUp to extract all available method signatures.

By correlating the external method calls from the client with the methods defined in each library, we constructed an accurate mapping between client calls and the corresponding library methods. This mapping enabled us to track how the behaviour of these methods evolved across versions.

As a result of this process, we obtained the JAR files for both the old and new versions of each library, along with a filtered list of external methods that are candidates for further analysis. These methods form the basis for detecting newly introduced unchecked exceptions that may lead to behavioural breaking changes in the client.

\subsection{Finding Newly Added Unchecked Exceptions}

Our goal is to detect whether upgrading a library introduces new unchecked exceptions that could affect client behaviour. To achieve this, we divide the process into two stages: first, identifying newly added unchecked exceptions using call graph analysis; and second, verifying their reachability from client input using taint analysis.

\subsubsection{Exception Discovery with RTA}

To detect newly added unchecked exceptions in the upgraded library, we first construct a call graph using \textbf{Rapid Type Analysis (RTA)} via SootUp~\cite{Karakaya24:_sootup}. We use RTA instead of \textbf{Class Hierarchy Analysis (CHA)} because RTA provides a more precise approximation of runtime behaviour. While CHA includes all methods defined in subclasses and interface implementations regardless of whether they are actually invoked, RTA considers only those types that are instantiated in the program, resulting in a more accurate and context-sensitive call graph.

In practice, CHA tends to over-approximate and report unreachable method calls. For example, in one case, CHA identified a path from the method \texttt{<com.alibaba.fastjson.JSONObject: java.lang.String getString (java.lang.String)>}, reporting an exception thrown in the \texttt{JSONObject} constructor as reachable. However, manual inspection revealed that this path was spuriousâ€”the method \texttt{getString} never actually reached the constructor in question. Using RTA eliminated such false positives by restricting analysis to only concretely instantiated types.

After building the RTA-based call graph, we traverse the reachable paths for each client-used method and collect all exceptions that are subclasses of \texttt{java.lang.RuntimeException} or \texttt{java.lang.Error}. These represent the complete set of unchecked exceptions that the client might be newly exposed to due to the library upgrade.

\subsubsection{Exception Verification with Taint Analysis}

Once the list of unchecked exceptions has been collected, we proceed to verify whether they are truly reachable from client-supplied inputs. This verification step is performed using \textbf{FlowDroid}~\cite{Arzt14:_flowdroid}, a static taint analysis framework. 

To enable taint analysis, we generate a \textit{driver stub} for each client-used method. The purpose of this stub is to declare each method parameter as a taint source. For each parameter, we define a wrapper function whose return value is marked as a source. The driver stub generation process is automated using SootUp and handles a wide variety of cases, including:
\begin{itemize}
  \item Constructor methods (\texttt{<init>} using \texttt{new ClassName(...)})
  \item Static and instance methods
  \item Void and non-void return types
  \item Primitive parameters (e.g., \texttt{int} $\rightarrow$ \texttt{0})
  \item Object parameters (defaulted to \texttt{null})
  \item Nested classes (converting \texttt{\$} to \texttt{.})
  \item Multiple parameters (sources named \texttt{SourceN()}, where $N$ is the parameter index)
  \item Overloaded methods (only one version retained)
\end{itemize}

Each exception collected during the RTA phase is treated as a \textit{taint sink}. For this analysis, we intentionally use \textbf{Class Hierarchy Analysis (CHA)} to construct the call graph for FlowDroid. Although CHA is less precise than RTA, its conservative nature is beneficial in this context. It ensures broader coverage, helping us avoid false negatives where actual flows might be missed due to the strictness of RTA.

Consider the following example from the \texttt{beam-sdks-java-core} library. The method \texttt{GroupByKey.applicableTo(PCollection)} throws an \texttt{IllegalStateException} under a specific condition:
\begin{lstlisting}[language=Java,breaklines=true,breakatwhitespace=false,basicstyle=\scriptsize\ttfamily]
public static void applicableTo(PCollection<?> input) {
    WindowingStrategy<?, ?> windowingStrategy = input.getWindowingStrategy();
    if (windowingStrategy.getWindowFn() instanceof GlobalWindows
        && windowingStrategy.getTrigger() instanceof DefaultTrigger
        && input.isBounded() != IsBounded.BOUNDED) {
      throw new IllegalStateException(
          "GroupByKey cannot be applied to non-bounded PCollection in the GlobalWindow without a"
              + " trigger. Use a Window.into or Window.triggering transform prior to GroupByKey.");
    }
}
\end{lstlisting}

Here, the source is the method parameter \texttt{input}, and the sink is the \texttt{IllegalStateException}. Since the exception is conditionally thrown, RTA does not resolve the path from the input parameter to the exception. However, due to its conservative over-approximation, CHA includes the conditional path, allowing the taint analysis to correctly identify the exception as being influenced by client input.

This trade-off justifies the use of CHA in the verification phase: although it may over-approximate in some cases, it ensures that no critical exception flows are missed.


\subsection{Verification of Unchecked Exceptions}
