As discussed in Section~\ref{sec:data-collection}, we evaluated UnCheckGuard on 1011 Java-based clients from the DUETS dataset~\cite{durieux21:_duets}.

The goal of our tool is to detect whether a client calls a library method that, upon upgrading the library to a newer version, introduces a previously non-existent unchecked exception—potentially resulting in a behavioural breaking change.

We explore the following research questions:

\begin{itemize}
  \item[\textbf{RQ1:}] Do library clients call methods with new added exceptions, and is it possible for the clients to trigger these exceptions? Furthermore, is it possible to write client-focussed test cases that trigger the exceptions?
  \item[\textbf{RQ2:}] For library changes that introduce triggerable new unchecked exceptions, under what circumstances do such exceptions occur (i.e. major/minor/patch versions)?
\end{itemize}

Table~\ref{tab:exception-funnel} summarizes our empirical findings about the prevalence of newly-added exceptions in our corpus and how their number changes as we perform more analysis stages.

\begin{table}[h]
\centering
\caption{Exception Analysis Funnel}
\label{tab:exception-funnel}
\begin{tabular}{l r}
\toprule
\textbf{Stage} & \textbf{Count} \\
\midrule
Client invocations of external methods & 15678 \\
% Newly added exceptions called by clients & 1708 \\
% We do not have this info, it will require another run (^_^)
Exceptions passing taint analysis & 1708 \\
% Exceptions with a manually-written test case & 3 \\
% I think we should not mention this number as it is significantly small
\bottomrule
\end{tabular}
\end{table}


\subsection{Client Calls to Newly-added Exceptions}

Our evaluation includes 1011 client applications, which depend on 302 distinct libraries. Across these, we formed 352 client-library pairs in which the library had an available upgrade, each corresponding to a combination of a specific client and one of the libraries that it depends on. Table~\ref{tab:version-changes} presents the top 15 client-library pairs, ordered in descending number of callsites that pass the taint analysis reachability filter; for each pair, it also presents the number of client callsites invoking library methods with newly-added exceptions.

UnCheckGuard detected 15678 callsites across these 352 pairs where the upgraded version of the library could throw a new unchecked exception. However, it was not possible to trigger all of these exceptions using the client's methods, even with a free choice of parameters to pass to the client code. We therefore applied a taint-based reachability analysis to filter out cases that definitely could not result in actual runtime failures. After this filtering step, we identified 1708 callsites in total—spanning 120 distinct libraries—that appeared to potentially be affected by a newly added unchecked exception.

We initially tried to write test cases for those 1708 cases but were often unable to write a test case that could trigger
the newly added unchecked exception. In most of the cases, we observed that the parameters responsible for triggering the 
exceptions were not the ones passed by the client to the library method.

As with the \texttt{protobuf} case in Section~\ref{sec:methodology}, which added a new-but-untriggerable unchecked exception, taint analysis played a crucial role in reducing the number of false positives.

\vspace{1em}
\begin{tcolorbox}[colback=gray!10, colframe=black]
By adding taint analysis, we reduced the number of potentially affected callsites from 15678 to just 1708.
\end{tcolorbox}
\vspace{1em}

To assess the real-world consequences of these remaining 1708 callsites, we manually constructed test cases. For 3 of the sites, we were able to provide inputs that trigger the newly added exceptions, confirming that they represent real behavioural breaking changes.

In other cases, the exception was not triggered immediately because the client passed hardcoded values or had safeguards like null checks.

\vspace{1em}
\begin{tcolorbox}[colback=gray!10, colframe=black]
\textbf{Answer RQ1:} Yes, client applications do call methods with newly added unchecked exceptions. Out of 352 client-library pairs in our corpus, we identified 1708 callsites that reached newly-added exceptions, distributed across 136 of our 1011 clients. We were able to construct test cases that trigger the exception in some cases.
\end{tcolorbox}
\vspace{1em}

\begin{table}[h]
\centering
\caption{Distribution of reachable newly-added exceptions across version types}
\label{tab:version-distribution}
\begin{tabular}{lcc}
\toprule
\textbf{Version Type} & \textbf{Libraries} \\
\midrule
Major Version Change & 50 \\
Minor Version Change & 57 \\
Patch Version Change & 14 \\
\bottomrule
\end{tabular}
\end{table}

\begin{table*}[hbt!]
\centering
\caption{Selected clients, libraries, versions, and counts of callsites reaching newly-added exceptions}
\label{tab:version-changes}
\begin{tabular}{>{\raggedright\arraybackslash\hangindent=2em}p{3.5cm} >{\raggedright\arraybackslash\hangindent=2em}p{3.5cm} >{\raggedright\arraybackslash\hangindent=2em}p{3.5cm} >{\raggedleft\arraybackslash}p{2cm} >{\raggedleft\arraybackslash}p{2cm}}
\toprule
\textbf{Client} & \textbf{Current Version} & \textbf{Latest Version} & \textbf{Number of Callsites} & \textbf{Reachable Callsites} \\
\midrule
codes.brewing.flinkexamples-1.0-SNAPSHOT & commons-logging-1.1.1 & commons-logging-1.1.3 & 3479 & 436 \\
\addlinespace
api-2.0.2 & gson-2.3 & gson-2.13.1 & 453 & 209 \\
\addlinespace
cosyan-0.0.1-SNAPSHOT & json-20180130 & json-20250517 & 365 & 112 \\
\addlinespace
TopicModelingTool & junit-4.11 & junit-4.13.2 & 308 & 78 \\
\addlinespace
android-facebook-1.6 & android-1.6\_r2 & android-4.1.1.4 & 154 & 77 \\
\addlinespace
indextank-engine-1.0.0 & commons-cli-1.2 & commons-cli-1.10.0 & 328 & 51 \\
\addlinespace
commons-pipeline-1.0-SNAPSHOT & commons-digester-1.7 & commons-digester-2.1 & 76 & 48 \\
\addlinespace
codes.brewing.flinkexamples-1.0-SNAPSHOT & commons-codec-1.3 & commons-codec-1.4 & 47 & 38 \\
\addlinespace
mrdpatterns-1.0-SNAPSHOT & hadoop-core-1.1.1 & hadoop-core-1.2.1 & 466 & 36 \\
\addlinespace
rehttp & xembly-0.31.1 & xembly-0.32.2 & 61 & 36 \\
\addlinespace
indextank-engine-1.0.0 & log4j-1.2.16 & log4j-1.2.17 & 33 & 33 \\
\addlinespace
Timeline-2.0.0 & tablestore-4.11.2 & tablestore-5.17.6 & 479 & 32 \\
\addlinespace
HospitalAction-1.0 & poi-5.2.2 & poi-5.4.1 & 42 & 28 \\
\addlinespace
MavenProject-0.0.1-SNAPSHOT & selenium-api-3.141.59 & selenium-api-4.35.0 & 120 & 24 \\
\addlinespace
amazon-kinesis-aggregators-.9.2.9 & commons-logging-1.1.1 & commons-logging-1.3.5 & 105 & 23 \\
\bottomrule
\end{tabular}
\end{table*}

\subsection{Newly-added Unchecked Exceptions in Java Libraries}
Semantic versioning~\cite{preston-werner23:_seman_version} proposes that version numbers have three parts, $x.y.z$. According to semantic versioning, library developers are to change the major version $x$ when an upgrade is breaking---that is, a client may have to modify their code to use the new versioning. Minor version upgrades (indicated by changes to $y$) may include new features, while patch upgrades (changes to $z$) fix bugs.

Table~\ref{tab:version-distribution} shows the distribution of newly-added exceptions reachable from clients, across upgrade types. Notably, 50 out of these 120 libraries introduced new unchecked exceptions as part of a major version bump. However, we also observed 14 cases in a patch version upgrade. While we are not making any broader claims about how often behavioural breaking changes occur in general, our results indicate that minor and patch upgrades do introduce behavioural breaking changes via unchecked exceptions which may affect clients—something that developers may not anticipate.

\vspace{1em}
\begin{tcolorbox}[colback=gray!10, colframe=black]
\textbf{Answer RQ2:} Java libraries introduce newly added unchecked client-relevant exceptions across versions frequently enough to be relevant to clients. We found newly added unchecked exceptions in 120 out of 302 distinct libraries (39.7\%). These changes in major version upgrades (50 times), minor version upgrades (57 times), and patch (14 times) version upgrades (e.g., \texttt{httpcore-4.4.6}~$\rightarrow$~\texttt{httpcore-4.4.16}).
\end{tcolorbox}
\vspace{1em}

\subsection{Discussion: Developer-Facing Implications}

Behavioural breaking changes caused by unchecked exceptions during API evolution are particularly dangerous. Such changes do not show up at compile time, and they do not affect method signatures, which means that the existing tools that we are aware of cannot detect them. For instance, both japicmp and Revapi, widely used tools for detecting breaking changes, focus on syntactic differences in method signatures. While they can both flag checked exceptions—since they appear in method declarations—they do not analyze the method implementations, and thus have no way of identifying newly added unchecked exceptions. As a result, developers who rely solely on either japicmp or revapi could remain unaware of serious runtime-breaking issues.

Some tools have tried to tackle the challenge of behavioural breaking changes. CompCheck~\cite{CompCheck}, for example, works by identifying test cases in some clients and reusing them for others with similar API usage. But this approach depends heavily on the presence of thorough test suites. Most clients that we have looked at do not have such comprehensive coverage, especially not for edge cases involving unchecked exceptions.

This is where UnCheckGuard steps in. Unlike existing work, it does not rely on existing test cases. Instead, it compares the old and new versions of a library using static analysis to detect newly added unchecked exceptions, and then runs taint analysis to filter out changes that do not affect the client. By avoiding the need for a test suite, it can reveal behavioural breaking changes that other tools overlook.

In doing so, UnCheckGuard addresses an important gap. It gives developers visibility into a class of breaking changes that are easy to miss but costly in practice—helping them catch potential failures early, before they reach production.
