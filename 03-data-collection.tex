This section describes the systematic approach we used to construct the dataset for our study on behavioural incompatibilities caused by newly added unchecked exceptions in upgraded Java libraries. 

Broadly, we require three key components: Java-based clients that depend on third-party libraries, the versions of the libraries declared as dependencies by these clients (``current'' versions), and the latest available versions of those same libraries (``latest'' versions). For each client-library pair, we also need to extract the set of unchecked exceptions thrown by the library methods actually used by the client.

To obtain this information, our methodology involves several key steps: identifying suitable Java clients, extracting their library dependencies, resolving both the current and latest versions of the libraries, analyzing exception behaviour in both versions, and recording all methods that introduce newly added unchecked exceptions. These steps enable our tool, UnCheckGuard, to report client call sites that may be affected by behavioural breaking changes.

\subsection{Collecting Clients}

To begin our analysis, we first collected suitable client projects. We used the DUETS dataset~\cite{durieux21:_duets}, which provides a curated list of Java-based clients hosted on GitHub, each with at least five stars. We attempted to download each client repository and discarded any client that failed to download.

Next, we checked whether the project included a \texttt{pom.xml} file, which indicates that it is a Maven-based project. This step was essential, as our analysis depends on running Maven commands. We compiled each client to produce a JAR file and kept only those clients that compiled successfully for further analysis.

\subsection{Library Version Resolution}

Our tool relies on analyzing both the version of the library currently used by the client and the latest available version (as stored in the Maven Central Repository). To collect the current version, we run the Maven command \texttt{mvn dependency:copy-dependencies}, which downloads all the dependencies declared in the client's build configuration.

To obtain the latest versions of these dependencies, we run the following Maven command:
\begin{lstlisting}[language=bash, breaklines=true, basicstyle=\ttfamily\small]
mvn org.codehaus.mojo:versions-maven-plugin:2.18.0:use-latest-versions
\end{lstlisting}
This command updates the \texttt{pom.xml} file with the most recent versions of all declared dependencies. We then re-run \texttt{mvn dependency:copy-dependencies} to download the updated set of libraries.

By following this process, we obtain both the original and the upgraded versions of each library used by the client, enabling us to perform a comparative analysis of behavioural changes across versions.

\subsection{Method and Exception Extraction}

We analyze the JAR file of the client application using SootUp to extract all external method invocations performed by the client (by external, we mean to methods outside the client). Based on this set of method calls, we analyze both the currently used version of the library and its latest available version.

To support this comparison, we also extract the list of methods present in the current version of the library. This allows us to match each external method call made by the client to its corresponding definition in the library. Using this information, we generate a JSON file that contains only the subset of library methods actually used by the client. This filtered list reduces the work necessary in subsequent steps.

\subsection{Comparing Library Versions}

Our tool detects newly added unchecked exceptions using static analysis and approximates their reachability using taint analysis. After collecting the unchecked exceptions from both the old and the latest versions of the library, we compare the sets of exceptions associated with each method in the library. We remove any duplicate exceptions that appear in both versions. If a method in the latest version throws an exception that was not present in the older version, we tag that method as having a newly added unchecked exception. Note that our methodology does not detect instances where the same exception is thrown by method, but under new circumstances.

Using the previously generated mapping between client call sites and library methods, we create a JSON file that lists each client method along with the corresponding external method call that triggers a newly added unchecked exception transitively reachable in the library. This output enables our tool to highlight call sites in the client application that may exhibit behavioural breaking changes, helping developers assess the impact of upgrading their dependencies.
