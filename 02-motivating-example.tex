We continue with a motivating example drawn from the DUETS collection~\cite{durieux21:_duets}
of client/library pairs. 
In our example,
a revision of the \texttt{httpcore} library adds a check for an
error condition.  If the condition holds, the library method will
explicitly throw an \texttt{IllegalArgumentException}. The client, \texttt{HttpAsyncClientUtils}\footnote{\url{github.com/a63881763/HttpAsyncClientUtils}},
calls the relevant part of the library, and thus may be affected by the new exception.

In the DUETS suite, our client, \texttt{HttpAsyncClientUtils}, declares a dependency on
version 4.4.6 of the \texttt{httpcore} library. Between the release of DUETS and today, the \texttt{httpcore} developers
have released a number of new versions, and at the time of writing, the latest version of \texttt{httpcore}
is 4.4.16.

\paragraph{Library} All constructors for the \texttt{org.apache.http.HttpHost} class transitively call
the static method \texttt{Args.containsNoBlanks()}. Between version 4.4.6 and version 4.4.16, the \texttt{httpcore}
developers added the following lines of code to \texttt{containsNoBlanks()}:
\begin{lstlisting}[language=Java]
  if (argument.length() == 0) {
    throw new IllegalArgumentException
      (name + `` may not be empty'');
  }
\end{lstlisting}
Specifically, all \texttt{HttpHost} constructors take a \texttt{hostname} parameter and call \texttt{containsNoBlanks()}
with that parameter (to check that it contains no blanks). It is therefore possible to trigger this newly-thrown
exception in a client by attempting to instantiate a new \texttt{HttpHost} object and passing it an empty
\texttt{hostname}.

Our UnCheckGuard tool analyzes the change in \texttt{httpcore} and reports that, in
version 4.4.16, all of the \texttt{HttpHost} constructors may now throw an
\texttt{IllegalArgumentException} via the \texttt{containsNoBlanks()} method.
This exception was not thrown in 4.4.6.

To detect this change, UnCheckGuard processes JAR files for both \texttt{httpcore-4.4.6} and \texttt{httpcore-4.4.16}. It uses SootUp~\cite{Karakaya24:_sootup} to construct an RTA-based call graph~\cite{bacon96:_fast_static_analy_c_virtual_funct_calls} starting from the public \texttt{<init>(String, int)}\footnote{Specifically, method \texttt{<init>(String, int)} returning a \texttt{void} on class \texttt{org.apache.http.HttpHost}} method and identifies the set of all transitively reachable methods. It starts from the public \texttt{<init>(String, int)} method as that is the method used by the client from \texttt{htttpcore} library. UnCheckGuard then collects all unchecked exceptions thrown within this set and applies taint analysis using FlowDroid~\cite{Arzt14:_flowdroid} to check whether method parameters controlled by the client can reach the exception sites. If the exception is unreachable from client code (in terms of taint analysis), then the client cannot supply values to the library which will trigger the exception. In version 4.4.6, it finds two sites throwing \texttt{IllegalArgumentException}, while in 4.4.16, it detects threeâ€”each of which the client can potentially trigger using the values it chooses to pass to the library as parameters.

\paragraph{Client} 
A newly-added exception is only relevant to a client if the client may
potentially trigger that exception.  It turns out that
our \texttt{HttpAsyncClientUtils} client has reachable code from the public \texttt{createAsyncClient(boolean)}\footnote{Fully-qualified: method \texttt{createAsyncClient(boolean)} returning a \texttt{CloseableHttpAsyncClient} on class \texttt{Util.HttpClientUtil.HttpAsyncClient}.} method
that creates an \texttt{HttpHost} with an empty \texttt{host}. The
public \texttt{createAsyncClient(boolean)} method takes a \texttt{proxy}
parameter and contains the following code:
\begin{lstlisting}[language=Java,basicstyle=\scriptsize\ttfamily]
 if (proxy) {
  return HttpAsyncClients.custom()
   .setConnectionManager(conMgr)
   .setDefaultCredentialsProvider(credentialsProvider)
   .setDefaultAuthSchemeRegistry(authSchemeRegistry)
   .setProxy(new HttpHost(host, port))
   .setDefaultCookieStore(new BasicCookieStore())
   .setDefaultRequestConfig(requestConfig).build();
 } else {
   // ...
\end{lstlisting}
where \texttt{host} is a private field initialized to the empty string.
Thus, calling \texttt{createAsyncClient(true)} triggers an exception when executed with
\texttt{httpcore} version 4.4.16 but not with 4.4.6.

To detect that our \texttt{HttpAsyncClientUtils} client calls a method from \texttt{httpcore-4.4.6} which, upon upgrading to \texttt{httpcore-4.4.16}, may throw a new unchecked exception, UnCheckGuard begins by identifying all external library methods invoked anywhere in the client. It then analyzes both the existing and the upgraded versions of the library. Using this analysis, it determines whether any newly introduced unchecked exceptions are reachable from the client's code. Here, reachability means that the client can trigger the exception in the library on some execution of the program, using values it passes to the library as parameters.

In order to check if the client-supplied values can reach the exception-throwing site, we use taint analysis. Taint analysis is essential in this scenario because a path from the client callsite to an exception-throwing statement is not sufficient to conclude that the exception is actually triggerable by the client. Many such paths may exist, but the control-flow conditions leading to the exception might depend entirely on internal library values, rather than on client-supplied inputs. Therefore, taint analysis becomes necessary to distinguish actual behavioural breaking changes from false positives.

Taint analysis helps by tracking whether any client-supplied value (source) can propagate to the conditional or operation that triggers the exception (sink). If taint analysis determines that no client-supplied input flows into the exception-triggering logic, then we can conclude that the newly added exception will not cause a behavioural breaking change.

This implies that a path exists in the interprocedural control-flow graph (which one can compute with Class Hierarchy Analysis (CHA)) from the client method to the statement throwing the exception in the library.

In this case, based on the confirmed reachability of the new exception, we report that the library-client pair \texttt{HttpAsyncClientUtils} and \texttt{httpcore} exhibits a behavioural breaking change.

Given this report, it is straightforward to write a test case that calls the client's \texttt{createAsyncClient()} method
and triggers the exception after an upgrade:
\begin{lstlisting}[language=Java,basicstyle=\scriptsize\ttfamily]
@Test
void testCreateAsyncClientThrowsExceptionForEmptyProxyHost() {
  HttpAsyncClient client = new HttpAsyncClient();

  IllegalArgumentException exception =
    assertThrows(IllegalArgumentException.class, () -> {
        client.createAsyncClient(true);
    });

    assertTrue(exception.getMessage()
    .contains("may not be empty"),
      "Expected exception due to empty hostname "+
      "after upgrading to httpcore-4.4.16");
}
\end{lstlisting}