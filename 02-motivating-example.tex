We continue with a motivating example drawn from the DUETS collection~\cite{durieux21:_duets}
of client/library pairs. 
Our example exhibits a case
where a revision of the \texttt{httpcore} library adds a check for an
error condition.  If the condition holds, the library method will
explicitly throw an \texttt{IllegalArgumentException}. The client, \texttt{HttpAsyncClientUtils},
calls the relevant part of the library, and thus may be affected by the new exception.

In the DUETS suite, our client, \texttt{HttpAsyncClientUtils}, declares a dependency on
version 4.4.6 of the \texttt{httpcore} library. Since the release of DUETS, the \texttt{httpcore} developers
have released a number of new versions, and at the time of writing, the latest version of \texttt{httpcore}
is 4.4.16.

\paragraph{Library} Specifically, all constructors for the \texttt{org.apache.http.HttpHost} class transitively call
the static method \texttt{Args.containsNoBlanks()}. Between version 4.4.6 and version 4.4.16, the \texttt{httpcore}
developers added the following lines of code to \texttt{containsNoBlanks()}:
\begin{lstlisting}[language=Java]
  if (argument.length() == 0) {
    throw new IllegalArgumentException
      (name + `` may not be empty'');
  }
\end{lstlisting}
All \texttt{HttpHost} constructors take a \texttt{hostname} parameter and call \texttt{containsNoBlanks()}
with that parameter (to check that it contains no blanks). It is therefore possible to trigger this newly-thrown
exception in a client by attempting to instantiate a new \texttt{HttpHost} object and passing it an empty
\texttt{hostname}.

Our UnCheckGuard tool analyzes the change in \texttt{httpcore} and reports that, in
version 4.4.16, all of the \texttt{HttpHost} constructors may now throw an
\texttt{IllegalArgumentException} via the \texttt{containsNoBlanks()} method.
This exception was not thrown in 4.4.6.

To detect this change, UnCheckGuard processes JAR files for both \texttt{httpcore-4.4.6} and \texttt{httpcore-4.4.16}. It uses SootUp~\cite{Karakaya24:_sootup} to construct an RTA-based call graph~\cite{bacon96:_fast_static_analy_c_virtual_funct_calls} starting from the \texttt{<org.apache.http.HttpHost: void <init>(java.lang.String,int)>} method and identifies all transitively reachable methods. UnCheckGuard then collects all unchecked exceptions thrown within this graph and applies taint analysis using FlowDroid~\cite{Arzt14:_flowdroid} to check whether method parameters controlled by the client can reach the exception sites. In version 4.4.6, it finds two sites throwing \texttt{IllegalArgumentException}, while in 4.4.16, it detects threeâ€”each of which the client can potentially trigger using the values it chooses to pass to the library as parameters.

\paragraph{Client} 
A newly-added exception is only relevant to a client if the client may
potentially trigger that exception.  It turns out that
our \texttt{HttpAsyncClientUtils} client has reachable code that
creates an \texttt{HttpHost} with an empty \texttt{host}. The
public \texttt{createAsyncClient(boolean)}\footnote{Specifically, method \texttt{createAsyncClient(boolean)} returning a \texttt{CloseableHttpAsyncClient} on class \texttt{Util.HttpClientUtil.HttpAsyncClient}} method takes a \texttt{proxy}
parameter and contains the following code:
\begin{lstlisting}[language=Java,basicstyle=\scriptsize\ttfamily]
 if (proxy) {
  return HttpAsyncClients.custom()
   .setConnectionManager(conMgr)
   .setDefaultCredentialsProvider(credentialsProvider)
   .setDefaultAuthSchemeRegistry(authSchemeRegistry)
   .setProxy(new HttpHost(host, port))
   .setDefaultCookieStore(new BasicCookieStore())
   .setDefaultRequestConfig(requestConfig).build();
 } else {
   // ...
\end{lstlisting}
where \texttt{host} is a private field initialized to the empty string.
Thus, calling \texttt{createAsyncClient(true)} triggers an exception when executed with
\texttt{httpcore} version 4.4.16 but not with 4.4.6.

To detect that our \texttt{HttpAsyncClientUtils} client calls a method from \texttt{httpcore-4.4.6} which, upon upgrading to \texttt{httpcore-4.4.16}, may throw a new unchecked exception, UnCheckGuard begins by identifying all external library methods invoked by the client. It then analyzes both the existing and the upgraded versions of the library. Using this analysis, it determines whether any newly introduced unchecked exceptions are reachable from the client's code. Here, reachability means
that the client can trigger the exception on some execution of the program, using values it passes as parameters,
which implies that a path exists in the interprocedural control-flow graph, computed with Class Hierarchy Analysis (CHA), from the client method to the exception-throwing site in the library.

In this case, based on the confirmed reachability of the new exception, we report that the library-client pair \texttt{HttpAsyncClientUtils} and \texttt{httpcore} exhibits a behaviuoral breaking change.

Given this report, it is not difficult to write a test case that calls the client's \texttt{createAsyncClient()} method
and triggers the exception after an upgrade:
\begin{lstlisting}[language=Java,basicstyle=\scriptsize\ttfamily]
@Test
void testCreateAsyncClientThrowsExceptionForEmptyProxyHost() {
  HttpAsyncClient client = new HttpAsyncClient();

  IllegalArgumentException exception =
    assertThrows(IllegalArgumentException.class, () -> {
        client.createAsyncClient(true);
    });

    assertTrue(exception.getMessage()
    .contains("may not be empty"),
      "Expected exception due to empty hostname "+
      "after upgrading to httpcore-4.4.16");
}
\end{lstlisting}




