We evaluated \textbf{UnCheckGuard} on Java-based clients from the DUETS dataset~\cite{durieux21:_duets}, selecting only those with at least 5 stars on GitHub to ensure practical relevance.

The goal of our tool is to detect whether a client calls a library method that, upon upgrading the library to a newer version, introduces a previously non-existent unchecked exception—potentially resulting in a behavioural breaking change.

We explore the following research questions:

\begin{itemize}
  \item[\textbf{RQ1:}] How often do published changes to Java libraries include new added exceptions, and under what circumstances do such exceptions occur (e.g., major/minor/patch versions)?
  \item[\textbf{RQ2:}] Do library clients, in practice, call methods with new added exceptions, and is it possible for the clients to trigger these exceptions? Is it possible to write client test cases that trigger the exceptions?
\end{itemize}

\subsection{Addition of Exceptions in Java Libraries}

Our evaluation included 36 client applications, which depended on 83 distinct libraries. Across these, we formed 98 client-library pairs, each corresponding to a combination of a specific client and one of its used libraries. 

UnCheckGuard detected 142 callsites across these 98 pairs where the upgraded version of the library introduced a previously unseen unchecked exception. However, not all of these exceptions were actually reachable from client-controlled input. We therefore applied a taint-based reachability analysis to identify only those cases that could result in actual runtime failures. After this filtering step, we identified 14 callsites in total—spanning 8 distinct libraries—that were definitively affected by a newly added unchecked exception. 

Notably, 6 out of these 8 libraries introduced such changes as part of a major version bump, which often signals breaking changes. However, we also observed one case each in a minor and a patch version upgrade. This indicates that even smaller upgrades may introduce behavioural breaking changes via unchecked exceptions—something developers may not anticipate.

\vspace{1em}
\begin{tcolorbox}[colback=gray!10, colframe=black]
\textbf{Answer RQ1:} Yes, Java libraries frequently introduce newly added unchecked exceptions across versions. Out of 98 client-library pairs, we identified 14 callsites affected by newly added unchecked exceptions across 8 libraries. These changes occurred not only in major version upgrades but also in minor and even patch versions (e.g., \texttt{httpcore-4.4.6}~$\rightarrow$~\texttt{httpcore-4.4.16}).
\end{tcolorbox}
\vspace{1em}

\begin{table}[h]
\centering
\caption{Distribution of Breaking Changes Across Version Types}
\label{tab:version-distribution}
\begin{tabular}{lcc}
\toprule
\textbf{Version Type} & \textbf{Libraries} & \textbf{Affected Call Sites} \\
\midrule
Major Version Change & 6 & 11 \\
Minor Version Change & 1 & 2 \\
Patch Version Change & 1 & 1 \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Impact on Clients}

UnCheckGuard not only identifies newly added exceptions but also helps assess their practical consequences for clients. In total, across all client-library pairs, we observed 8047 external method invocations. Among these, 142 targeted methods that throw a new unchecked exception in the upgraded version. After applying reachability filtering, 14 of these callsites were confirmed to potentially have a behavioural breaking change. 

To further evaluate the real-world impact of these changes, we attempted to construct test cases that could trigger the exception at runtime. In most of these cases, we successfully created such test inputs, confirming that the exception could propagate to the client. This validates that these changes are not merely theoretical but represent concrete runtime risks.

In a few instances, our analysis identified callsites where the client code either passed a hardcoded value or included precondition checks (e.g., null checks) that prevented the exception from being triggered under current conditions. While these cases did not result in immediate runtime failures, they remain important for developers to monitor. Future code changes—for instance, removing a check or altering the passed argument—could unknowingly expose these callsites to the newly added exception, leading to a breaking change.

\vspace{1em}
\begin{tcolorbox}[colback=gray!10, colframe=black]
\textbf{Answer RQ2:} Yes, client applications do call methods with newly added unchecked exceptions. We confirmed 14 such callsites across our corpus. For most of these, we were able to construct test cases that trigger the exception. In others, the exception was guarded by a hardcoded value or a conditional check, but these callsites remain latent risks that could become active under future client code modifications.
\end{tcolorbox}
\vspace{1em}

\subsection{Developer-Facing Implications}

Behavioural breaking changes caused by unchecked exceptions during API evolution are particularly dangerous. They don’t show up at compile time, and they don’t affect method signatures, which means most existing tools simply miss them. For instance, \textbf{JAPICMP}\footnote{https://github.com/siom79/japicmp}, a widely used tool for detecting breaking changes, focuses only on syntactic differences in method signatures. While it can flag checked exceptions—since they appear in method declarations—it has no way of identifying newly added unchecked exceptions. As a result, developers who rely solely on JAPICMP might remain unaware of serious runtime-breaking issues.

Some tools have tried to tackle the challenge of behavioural breaking changes. \textbf{CompCheck}~\cite{CompCheck}, for example, works by identifying test cases in some clients and reusing them for others with similar API usage. But this approach depends heavily on the presence of thorough test suites. In practice, most clients don’t have such comprehensive coverage, especially not for edge cases involving unchecked exceptions.

This is where \textbf{UnCheckGuard} steps in. It doesn’t rely on existing test cases. Instead, it compares the old and new versions of a library using static analysis to detect newly added unchecked exceptions, and then runs taint analysis to verify which ones might actually affect the client. By avoiding the need for a test suite, it can reveal behavioural breaking changes that other tools completely overlook.

In doing so, \textbf{UnCheckGuard} fills an important gap. It gives developers visibility into a class of breaking changes that are easy to miss but costly in practice—helping them catch potential failures early, before they reach production.
