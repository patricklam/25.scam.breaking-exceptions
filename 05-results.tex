We evaluated UnCheckGuard on Java-based clients from the DUETS dataset~\cite{durieux21:_duets}, selecting only clients with at least 5 stars on GitHub to ensure practical relevance.

The goal of our tool is to detect whether a client calls a library method that, upon upgrading the library to a newer version, introduces a previously non-existent unchecked exception—potentially resulting in a behavioural breaking change.

We explore the following research questions:

\begin{itemize}
  \item[\textbf{RQ1:}] How often do published changes to Java libraries throw new unchecked exceptions in methods,
and under what circumstances do such exceptions occur (e.g. major/minor/patch versions)?
  \item[\textbf{RQ2:}]  Do library clients, in practice, call methods with new added exceptions, and is it possible for the clients to trigger these exceptions? Is it possible to write client test cases that trigger the exceptions?
\end{itemize}

\todo{There is a funnel from newly-added exceptions to exceptions called by the client to exceptions called by the client where the client can exploit the new exception to exceptions where we have a test case. It could go here.}

\subsection{Newly-added Unchecked Exceptions in Java Libraries}

Our evaluation included 36 client applications, which depended on 68 distinct libraries. Across these, we formed 98 client-library pairs, each corresponding to a combination of a specific client and one of the libraries that it depends on. Some of the libraries were used by multiple clients.



UnCheckGuard detected 142 callsites across these 98 pairs where the upgraded version of the library could throw a new unchecked exception. However, it was not possible to trigger all of these exceptions using the client's methods, even with a free choice of parameters to pass to the client code. We therefore applied a taint-based reachability analysis to filter out cases that definitely could not result in actual runtime failures. After this filtering step, we identified 14 callsites in total—spanning 8 distinct libraries—that appeared to potentially be affected by a newly added unchecked exception. \todo{how many did we write test cases for? - 6, 3 trigger the exception and 3 fails to do it because of safety checks/harcoded values}

Notably, 6 out of these 8 libraries introduced such changes as part of a major version bump, which often signals breaking changes. However, we also observed one case each in a minor and a patch version upgrade. This indicates that even smaller upgrades may introduce behavioural breaking changes via unchecked exceptions—something developers may not anticipate.

\vspace{1em}
\begin{tcolorbox}[colback=gray!10, colframe=black]
\textbf{Answer RQ1:} Java libraries introduce newly added unchecked client-relevant exceptions across versions frequently enough to be relevant to clients. Out of 98 client-library pairs, we identified 14 callsites affected by newly added unchecked exceptions across 8 libraries (8\%). These changes occurred in major version upgrades (6 times) but also in minor (1) and even patch (1) version upgrades (e.g., \texttt{httpcore-4.4.6}~$\rightarrow$~\texttt{httpcore-4.4.16}).
\end{tcolorbox}
\vspace{1em}

\begin{table}[h]
\centering
\caption{Distribution of Breaking Changes Across Version Types}
\label{tab:version-distribution}
\begin{tabular}{lcc}
\toprule
\textbf{Version Type} & \textbf{Libraries} & \textbf{Affected Call Sites} \\
\midrule
Major Version Change & 6 & 11 \\
Minor Version Change & 1 & 2 \\
Patch Version Change & 1 & 1 \\
\bottomrule
\end{tabular}
\end{table}

\begin{table*}[hbt!]
\centering
\caption{Version Changes and Associated Clients with Occurrence Counts}
\label{tab:version-changes}
\begin{tabular}{c >{\raggedright\arraybackslash}p{3.5cm} >{\raggedright\arraybackslash}p{3.5cm} >{\raggedright\arraybackslash}p{6cm} >{\centering\arraybackslash}p{2cm}}
\toprule
\# & \textbf{Old Version} & \textbf{New Version} & \textbf{Clients (Occurrences)} & \textbf{Client with BBC(Occurrences)} \\
\midrule
1 & beam-sdks-java-core-2.9.0 & beam-sdks-java-core-2.65.0 & enrichment-patterns-1.0-SNAPSHOT (7) & \\
2 & beam-sdks-java-io-google-cloud-platform-2.9.0 & beam-sdks-java-io-google-cloud-platform-2.65.0 & enrichment-patterns-1.0-SNAPSHOT (3) & \\
3 & cglib-2.2.2 & cglib-3.3.0 & pattern-1.0-SNAPSHOT (4), tiny-spring-1.0-SNAPSHOT (2) & \\
4 & commons-beanutils-1.8.0 & commons-beanutils-1.11.0 & firebrand-1.0-SNAPSHOT (10) & \\
5 & commons-beanutils-1.9.3 & commons-beanutils-1.11.0 & tiny-spring-1.0-SNAPSHOT (1) & \\
6 & commons-csv-1.3 & commons-csv-1.14.0 & tushare-1.0.0 (2) & \\
7 & commons-logging-1.1.1 & commons-logging-1.1.3 & observer-1.0-SNAPSHOT (1) & \\
8 & commons-logging-1.1.1 & commons-logging-1.3.5 & 52n-v3d-triturus-2.0.0-SNAPSHOT (3), firebrand-1.0-SNAPSHOT (3) & \\
9 & fastjson-1.2.23 & fastjson-2.0.57 & tushare-1.0.0 (14) & \\
10 & fastjson-1.2.31 & fastjson-2.0.57 & neuron-0.0.1 (5) & \\
11 & fastjson-1.2.54 & fastjson-2.0.57 & ROOT (22) & \\
12 & fastjson-1.2.58 & fastjson-2.0.57 & javaTest-1.0-SNAPSHOT (1) & \\
13 & httpcore-4.4.6 & httpcore-4.4.16 & HttpAsyncClientUtils-1.0-SNAPSHOT (1) & HttpAsyncClientUtils-1.0-SNAPSHOT (1)\\
14 & hutool-all-4.6.8 & hutool-all-5.8.38 & ROOT (1) & \\
15 & jfinal-3.8 & jfinal-5.2.2 & im-0.0.1-SNAPSHOT (1) & \\
16 & jfinal-4.5 & jfinal-5.2.5 & ROOT (3) & \\
17 & maxmind-db-1.2.2 & maxmind-db-3.2.0 & javaTest-1.0-SNAPSHOT (2) & \\
18 & netty-all-4.1.32.Final & netty-all-4.1.107.Final & tiny-spring-1.0-SNAPSHOT (4) & \\
19 & poi-3.17 & poi-5.4.1 & ROOT (14) & ROOT (5)\\
20 & spring-aop-4.3.7.RELEASE & spring-aop-6.1.6 & tiny-spring-1.0-SNAPSHOT (5) & \\
21 & spring-core-4.3.7.RELEASE & spring-core-6.1.6 & tiny-spring-1.0-SNAPSHOT (16) & \\
22 & spring-webmvc-4.3.7.RELEASE & spring-webmvc-6.1.6 & tiny-spring-1.0-SNAPSHOT (14) & \\
23 & sonar-plugin-api-7.4 & sonar-plugin-api-9.4.0.54424 & sonar-pmd-plugin-3.0.1 (3) & \\
\bottomrule
\end{tabular}
\end{table*}


\subsection{Effectiveness of Taint Analysis}

We apply taint analysis in our tool to help filter out irrelevant answers. When we run our tool based only on an RTA-based call graph, which
searches for unchecked exceptions in the transitively called method bodies as well as in the entry method's body, we get
142 callsites that potentially might have an unchecked exception that can cause a behavioural breaking change.

We initially tried to write test cases for those 142 cases but were often unable to write a test case that could trigger
the newly added unchecked exception. In most of the cases, we observed that the parameters responsible for triggering the 
exceptions were not the ones passed by the client to the library method.

We have discussed a case in Section~\ref{sec:methodology} where a newly added unchecked exception was present, but the client-supplied input was unable to trigger it. In that case, as well as in other similar instances we observed, taint analysis played a crucial role in eliminating such false positives.

\vspace{1em}
\begin{tcolorbox}[colback=gray!10, colframe=black]
By adding taint analysis, we reduced the number of potentially affected callsites from 142 to just 14.
\end{tcolorbox}
\vspace{1em}


\subsection{Impact on Clients}

\todo{I think subsection B and C could be one subsection, or else we move the first paragraph up to B, and C is the ``we write manual test cases''}.
UnCheckGuard not only identifies newly added exceptions but also helps assess their practical consequences for clients. In total, across all client-library pairs, we observed 8047 external method invocations. Among these, 142 invoked library methods throw a new unchecked exception in the upgraded version. After applying reachability filtering, we retained 14 of these callsites as invoking methods with potential behavioural breaking changes. 

To further evaluate the real-world impact of these changes, we attempted to construct test cases that could trigger the exception at runtime. In most of these cases\todo{how many? should be in the results table}, we successfully created such test inputs, confirming that the exception could propagate to the client. This validates that these changes are not merely theoretical but represent concrete runtime risks.

In a few instances, our analysis identified callsites where the client code either passed a hardcoded value or included precondition checks (e.g., null checks) that prevented the exception from being triggered under current conditions. While these cases did not result in immediate runtime failures, they remain important for developers to monitor. Future code changes—for instance, removing a check, or altering the passed argument—could unknowingly expose these callsites to the newly added exception, leading to a breaking change.
\todo{we should make data available including the cases - pending}

\vspace{1em}
\begin{tcolorbox}[colback=gray!10, colframe=black]
\textbf{Answer RQ2:} Yes, client applications do call methods with newly added unchecked exceptions. We confirmed 14 such callsites across our corpus. We were able to construct test cases that trigger the exception. In others, the exception was guarded by a hardcoded value or a conditional check, but these callsites remain latent risks that could become active under future client code modifications.
\end{tcolorbox}
\vspace{1em}

\subsection{Discussion: Developer-Facing Implications}

Behavioural breaking changes caused by unchecked exceptions during API evolution are particularly dangerous. Such changes do not show up at compile time, and they do not affect method signatures, which means that the existing tools that we are aware of cannot detect them. For instance, both japicmp\footnote{https://github.com/siom79/japicmp} and revapi\footnote{https://revapi.org/revapi-site/main/index.html}, widely used tools for detecting breaking changes, focus on syntactic differences in method signatures. While they can both flag checked exceptions—since they appear in method declarations—they do not analyze the method implementations, and thus have no way of identifying newly added unchecked exceptions. As a result, developers who rely solely on either japicmp or revapi could remain unaware of serious runtime-breaking issues.

Some tools have tried to tackle the challenge of behavioural breaking changes. CompCheck~\cite{CompCheck}, for example, works by identifying test cases in some clients and reusing them for others with similar API usage. But this approach depends heavily on the presence of thorough test suites. In practice, most clients do not have such comprehensive coverage, especially not for edge cases involving unchecked exceptions.

This is where UnCheckGuard steps in. Unlike existing work, it does not rely on existing test cases. Instead, it compares the old and new versions of a library using static analysis to detect newly added unchecked exceptions, and then runs taint analysis to filter out changes that do not affect the client. By avoiding the need for a test suite, it can reveal behavioural breaking changes that other tools overlook.

In doing so, UnCheckGuard addresses an important gap. It gives developers visibility into a class of breaking changes that are easy to miss but costly in practice—helping them catch potential failures early, before they reach production.
