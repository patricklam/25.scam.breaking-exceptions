We define some concepts that underpin our approach to detecting
behavioural breaking changes caused by newly added exceptions.

\textbf{Taint Analysis}. Taint analysis is a program analysis technique which can be implemented statically~\cite{myers99:_jflow} or dynamically~\cite{newsome05:_dynam}.
It relies on declarations of sources (for example, client input) and sinks (for example, critical
operations or exceptions). Given these inputs, the analysis tracks whether the sources can reach the sinks.

The following example demonstrates how taint flows from a source to a sink:

\begin{lstlisting}[language=java,basicstyle=\scriptsize\ttfamily]
public class FlowDroidExampleCode {
  public static int source() { return 1337; }

  public void exampleTaintAnalysis() {
    int temp = source(); int[] arr = new int[2];
    arr[0] = temp; arr[1] = 19;
    if (arr[0] == 1337) {
      throw new RuntimeException("hello"); }
    }
}
\end{lstlisting}

In this example, the method \texttt{source()} acts as the taint source. The statement \texttt{throw new RuntimeException("hello")} is the sink. The tainted value flows into the array \texttt{arr}, and later influences the conditional that triggers the exception. Although the exception is hardcoded, the fact that its execution depends on a tainted value makes this a valid taint flow from the source to the sink.

We apply taint analysis to detect whether newly added exceptions in a library are reachable from client-supplied values. This helps us detect behavioural breaking changes where a newly added unchecked exception is only triggered under specific conditions influenced by the client.

\textbf{SootUp}. SootUp~\cite{Karakaya24:_sootup} is a respin of the Soot~\cite{vallee2010soot} framework that supports static analysis of Java bytecode.

SootUp transforms JVM bytecode into the intermediate representation Jimple, which simplifies analysis by converting low-level bytecode instructions into a higher-level format that makes method bodies, variable assignments, exception handling blocks, and method invocations accesible. SootUp also provides call graph generation with various algorithms and precision levels. When a library method throws a new unchecked exception, we use SootUp to determine whether client methods transitively call that library method by traversing the (Class Hierarchy Analysis) call graph. We also use the Jimple intermediate representation to inspect methods that may throw an exception, by examining throw statements and method calls within their bodies.

\textbf{FlowDroid}. FlowDroid~\cite{Arzt14:_flowdroid} is a static taint analysis framework. It tracks data flow from declared sources to sinks within the application's code. It is built on top of the Soot~\cite{vallee2010soot} static analysis framework. FlowDroid models the complete Android lifecycle and callback structure---irrelevant for our purposes---but, relevant to us, enables flow-sensitive, field-sensitive, context-sensitive, and object-sensitive analysis of both Android and normal Java Virtual Machine programs.

It checks whether data from a source will taint a sink by computing possible paths along which the data can flow. In our tool, we use taint analysis to check the approximate reachability of newly added unchecked exceptions from client code.
